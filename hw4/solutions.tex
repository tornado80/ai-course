\documentclass{article}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{qtree}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[margin=1in]{geometry}
\usepackage{xepersian}
\settextfont{Yas}
% Fixture for Xepersian 23 bug of setting persian math digit fonts
\ExplSyntaxOn\cs_set_eq:NN\etex_iffontchar:D\tex_iffontchar:D\ExplSyntaxOff
\setmathdigitfont{Yas}
\onehalfspacing
\title{
	تمرین چهارم هوش مصنوعی
}
\author{
	امیرحسین رجبی (۹۸۱۳۰۱۳)
}
\renewcommand{\labelenumi}{\alph{enumi})}
\lstset{
	language=Python, 
	basicstyle=\ttfamily, 
	tabsize=4, 
	frame=single,
	commentstyle=\itshape\color{lightgray},
	keywordstyle=\bfseries\color{blue},
	identifierstyle=\color{black},
	stringstyle=\color{red}, 
	numbers=left
}
\bibliographystyle{plain}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=blue,
	citecolor = black,      
	urlcolor=cyan,
}
\newcommand{\code}[1]{\lr{\lstinline|#1|}}
\onehalfspacing
\begin{document}
	\maketitle
	
	\section*{
	سوال اول
	}
	در بازی‌های مجموع غیر صفر هر بازیکن عایدی
	\LTRfootnote{payoff}
	جداگانه دارد و به هر نود درخت یک $n$-تایی نسبت داده می‌شود که هر مولفه عایدی بازیکن نظیر را نشان می‌دهد و هر بازیکن به دنبال بیشینه کردن عایدی خودش است. (به عنوان مثال عایدی یک نود می‌تواند 
	$(x, y)$
	باشد در حالی که در بازی‌های مجموع صفر به صورت
	$(x, -x)$
	است.) اگر عایدی بازیکنان توسط دو تابع جداگانه مشخص شود، هر بازیکن در درخت مربوط به مولفه خود (در نوبت خود) در حال انتخاب راس با عایدی بیشینه برای خودش است. ممکن است در این میان با بازیکن روبرو همکاری یا رقابت کند؛ ولی با استراتژی بیان شده این اتفاق به صورت عمدی نخواهد بود. در نتیجه اجرای آلفا-بتا روی مقادیر مولفه مربوط به یک بازیکن جواب معتبری نمی‌دهد؛ زیرا بازیکنان با هم رقابت نمی‌کنند و کاهش عایدی یک بازیکن به معنی افزایش عایدی دیگری نیست.
	
	\section*{
	سوال دوم	
	}
	\begin{enumerate}
		\item 
	در درخت 
	\lr{max}
	در هر نود در حال انتخاب فرزند با عایدی بیشینه هستیم. و برگ درخت با بیشترین مقدار به عنوان عایدی بازی در نظر گرفته می‌شود. هرس نمی‌توان انجام داد زیرا نود با بیشترین مقدار در هر شاخه‌ای می‌تواند باشد و همه شاخه‌ها باید بررسی شوند. اگر زودهنگام هرس کنیم و نودی با مقدرا بزرگتر بعدا دیده شود دچار مشکل می‌شویم.
	
	در درخت 
	\lr{expectimax}
	ماجرا کمی متفاوت است. نمی‌توان عملیات هرس آلفا-بتا را انجام داد چرا که عایدی راس
	\lr{chance}
	از امید ریاضی فرزندان مشخص می‌شود و به دلیل کران دار نبودن عایدی، همه فرزاندان باید بررسی شوند. (در صورت هرس زود هنگام و وجود راسی با عایدی بسیار بزرگ در \lr{sibling}‌های بعدی، ورق در امید ریاضی فرزندان می‌تواند برگردد!)
	\item
	برای درخت 
	\lr{max}
	وضعیت مانند گذشته است چرا که از کران دار نبودن مقادیر رئوس و برگ‌ها استفاده نکردیم. تنها حالت استثنا این است که مقدار یک راس ۱ باشد. در این صورت نیازی به بررسی \lr{sibling}ها نخواهیم داشت و می‌توان این شاخه را هرس کرد و عایدی این شاخه برابر ۱ خواهد بود. برای درخت 
	\lr{expectimax}
	نیز مانند مورد قبل مثال نقض وجود دارد. درخت زیر را در نظر بگیرید. احتمال انتخاب هر فرزند هر راس 
	\lr{chance}
	برابر 
	$\frac{1}{2}$
	در نظر می‌گیریم. شاخه $e_2$ به دلیل 
	$\frac{1}{4} < \frac{1}{2} \times \frac{1}{3} + \frac{1}{2} \times \frac{2}{3} = \frac{1}{2}$
	هرس می‌شود در حالی که بهین است.
	\begin{figure*}[h]
		\setLTR
		\Tree [.{$m$} [.{$e_1$} [.{$1/3$} ] [.{$2/3$} ]] [.{$e_2$} [.{$1/4$} ] [.{$7/8$} ]] ]
	\end{figure*}
	البته در بعضی حالات هرس ممکن است. در درخت زیر احتمال انتخاب هر فرزند راس 
	\lr{chance}
	برابر 
	$\frac{1}{2}$
	است. امید فرزندان $e_1$ برابر 
	$\frac{3}{4}$
	است. از طرفی 
	فرزند چپ $e_2$ برابر 
	$\frac{1}{3}$
	است و چون
	$\frac{1}{3} < \frac{3}{4}$
	طبق الگوریتم شاخه $e_2$ هرس می‌شود و مشکلی نیز ایجاد نمی‌شود. چرا که امید فرزندان 
	$e_2$
	برابر است با
	$\frac{1}{2} \times \frac{1}{3} + \frac{1}{2} \times x = \frac{1}{6} + \frac{x}{2} < \frac{1}{6} + \frac{1}{2} = \frac{2}{3} < \frac{3}{4}$.
		\begin{figure*}[h]
		\setLTR
		\Tree [.{$m$} [.{$e_1$} [.{$1$} ] [.{$1/2$} ] ] [.{$e_2$} [.{$1/3$} ] [.{$x$} ] ] ]
	\end{figure*}
	\end{enumerate}
	\section*{
		سوال سوم
	}
	اگر بازیکن 
	\lr{min}
	بهینه بازی نکند همچنان بازیکن
	\lr{max}
	حداقل همان عایدی را خواهد داشت که \lr{min} بهینه بازی کند ولی در این صورت ممکن است از ماجرا بهره کامل نبرد؛ یعنی بتواند بهتر از عایدی که
	\lr{minimax}
	ارائه می‌دهد را نصیب خودش کند. در این حالت بهتر است از 
	\lr{expectimax}
	بهره برد تا به کمک امید ریاضی و احتمالی فرض کردن حریف عایدی بیشتری کسب کرد.
	
	\section*{سوال چهارم}
	\begin{enumerate}
		\item 
		اگر
		$\alpha \models (\beta \wedge \gamma)$
		یعنی
		$M(\alpha) \subseteq M(\beta \wedge \gamma)$. 
		اما به سادگی می‌توان دید که 
		$M(\beta \wedge \gamma) = M(\beta) \cap M(\gamma)$. 
		زیرا هر مدلی که هر دو جمله
		$\beta$
		و
		$\gamma$
		در آن درست باشند در اشتراک مدل هر کدام قرار دارد و برعکس. پس
		$M(\alpha) \subseteq M(\beta) \cap M(\gamma)$
		و در نتیجه
		$M(\alpha) \subseteq M(\beta)$
		و همچنین
		$M(\alpha) \subseteq M(\gamma)$
		یا معادلا
		$\alpha \models \beta$
		و
		$\alpha \models \gamma$.
		\item
		اگر 
		$\alpha \models (\beta \vee \gamma)$
		یعنی 
		$M(\alpha) \subseteq M(\beta \vee \gamma) $.
		اما
		$M(\beta \vee \gamma) = M(\beta) \cup M(\gamma)$. 
		چرا که هر مدلی که در آن حداقل یکی از دو جمله $\beta$ و $\gamma$ درست باشند، عضوی از مدل $\beta$ یا $\gamma$  خواهد بود و برعکس. پس 
		$M(\alpha) \subseteq M(\beta) \cup M(\gamma)$
		و در نتیجه
		$M(\alpha) \subseteq M(\beta)$
		یا (منطقی)
		$M(\alpha) \subseteq M(\gamma)$.
		معادلا داریم:
		$\alpha \models \beta$
		یا (منطقی)
		$\alpha \models \gamma$.
		
	\end{enumerate}
\section*{سوال پنجم}
ابتدا همه جملات $KB$ را به فرم نرمال عطفی
\LTRfootnote{Conjunctive Normal Form (CNF)}
تبدیل می‌کنیم. خواهیم داشت:
\begin{align}
	A \iff (B \vee E) \equiv (\neg A \vee B \vee E) \wedge \Big( \neg (B \vee E) \vee A \Big) &\equiv (\neg A \vee B \vee E) \wedge (\neg B \vee A) \wedge (\neg E \vee A) \tag{$S_1$} \\
	E \Longrightarrow D &\equiv \neg E \vee D \tag{$S_2$} \\
	C \wedge F \Longrightarrow \neg B &\equiv \neg C \vee \neg F \vee \neg B \tag{$S_3$} \\
	E \Longrightarrow B &\equiv \neg E \vee B \tag{$S_4$} \\
	B \Longrightarrow F &\equiv \neg B \vee F \tag{$S_5$} \\
	B \Longrightarrow C &\equiv \neg B \vee C \tag{$S_6$} 
\end{align}
اکنون سعی می‌کنیم به کمک قواعد 
\lr{resolution}
نشان دهیم 
$KB \models \neg A \wedge \neg B$
یا معادلا با فرض
$KB \wedge \neg (\neg A \wedge \neg B) \equiv KB \wedge (A \vee B)$
به تناقض برسیم. پس جملات زیر را داریم:
$$\boxed{A \vee B} \; \boxed{\neg B \vee C} \; \boxed{\neg B \vee F} \; \boxed{\neg E \vee B} \; \boxed{\neg C \vee \neg F \vee \neg B} \; \boxed{\neg E \vee D} \; \boxed{\neg A \vee B \vee E} \; \boxed{\neg B \vee A} \; \boxed{\neg E \vee A}$$
درخت زیر نحوه استدلال از جملات بالا را از برگ‌ها به سمت ریشه درخت نشان می‌دهد. با توجه به درخت به جمله تهی رسیده‌ایم و از 
$A \vee B$
نیز استفاده نکردیم. پس $KB$ فعلی خود دارای تناقض است و 
$M(KB) = \varnothing$.
پس 
$M(KB) \subseteq M(\neg A \wedge \neg B)$
و حکم ثابت می‌شود.
\begin{figure*}[h]
	\setLTR
	\Tree [.$\boxed{}$ [.{$\boxed{\textcolor{red}{\neg A} \vee \textcolor{red}{A}}$} [.$\boxed{\neg A \vee \textcolor{red}{B}}$ {$\boxed{\neg A \vee B \vee \textcolor{red}{E}}$} {$\boxed{\textcolor{red}{\neg E} \vee B}$} ] {$\boxed{\textcolor{red}{\neg B} \vee A}$} ] ]
\end{figure*}

\section*{گزارش پیاده سازی}
با اجرای فایل 
\code{main.py}
می‌توان برنامه را اجرا کرد. برنامه از چهار کلاس
\code{TicTacToe}، 
\code{Player}،
\code{Agent}
و
\code{Human}
تشکیل شده که دو کلاس 
\code{Agent}
و 
\code{Human}
از 
\code{Player}
ارث برده و دو نوع پیاده سازی بازیکن هستند. کلاس 
\code{TicTacToe}
به کمک تابع 
\code{run()}
بازی را شبیه سازی کرده و به نوبت تابع
\code{move(state)}
هر یک از بازیکنان را با ورودی دادن وضعیت بازی به آن‌ها اجرا می‌کند. (نتیجه بازی در فیلد 
\code{winner}
قرار می‌گیرد و در صورت 
\code{None}
بودن به معنی تساوی است و در غیر این صورت شی متناظر بازیکن برنده برگردانده می‌شود.) کلاس 
\code{Human}
این تابع رو اینگونه پیاده سازی کرده که ورودی از کاربر گرفته می‌شود و وضعیت بازی تغییر داده می‌شود. در مقابل کلاس 
\code{Agent}
از الگوریتم
\lr{minimax}
استفاده می‌کند. بنابراین می‌توان هر دو نوع حریفی را مقابل یک دیگر قرار داد و بازی کرد. (مثلا در صورت قرار دادن کامپیوتر مقابل بازی همواره به تساوی می‌کشد چرا که هر دو از استراتژی نباخت استفاده می‌کنند.) وضعیت‌ها به صورت یک آرایه به طول ۹ نگه داری می‌شوند و هر درایه یکی از سه مقدار 
\code{x}،
\code{o}
یا
\code{-}
دارد و تابع استایتک
\code{status(state)}
از کلاس 
\code{TicTacToe}
با ورودی گرفتن یک وضعیت مشخص می‌کند که آیا 
\code{x}
برده است یا
\code{o}
برده است یا
بازی تساوی شده است یا اصلا تمام نشده است. به کمک این تابع کلیدی، تابع
\code{is\_finished() -> bool}
مشخص می‌کند بازی تمام شده است یا خیر و در صورت پایان بازی، برنده را در فیلد 
\code{winner}
قرار می‌دهد. دوباره به کمک تابع 
\code{status()}،
تابع 
\code{utility(state)}
مقداری بین 0، 1 و $-1$ برمی‌گرداند. (برای بهینه کردن تعداد فراخوانی‌ها در صورت عدم اتمام بازی \code{None} برمی‌گرداند.) در نهایت تابع 
\code{minimax(state, player\_type, alpha, beta)}
به کمک 
\code{utility()}،
مقدار عایدی وضعیت فعلی و بهترین حرکت را برمی‌گرداند. (تعداد فراخوانی‌های این تابع در یک فیلد ذخیره شده و قبل از هر حرکت توسط \code{move()} صفر می‌شود و بعد از مشخص شدن بهترین حرکت به کاربر نمایش داده می‌شود.) شایان ذکر است که \code{minimax()} وضعیت فعلی را دست نخورده تحویل می‌دهد و در نتیجه دائما نیازی به ساخت آرایه به طول ۹ ندارد و در مصرفه حافظه صرفه جویی می‌شود. همچنین هرس به روش آلفا-بتا تنها زمانی انجام می‌شود که هنگام ساخت 
\code{Agent}
ذکر شود. (به صورت پیش فرض هرش انجام می‌شود.) مقایسه تعداد رئوس بررسی شده توسط مینی ماکس عادی با مینی ماکس هرس شده هیجان انگیز است. عامل برای اولین حرکت با مینی ماکس عادی حدود 549946 وضعیت را بررسی می‌کند. (کافی است عامل را به صورت \code{agent = Agent(..., alpha\_beta\_pruning=False)} بسازید و هنگام ساخت بازی کامپیوتر را نفر اول قرار دهید.) اما با فعال کردن آن تنها حدود 18297 وضعیت بررسی می‌شود!
\end{document}